<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sistema Solar 3D & Mapa Mundi</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        
        /* Estilo do Menu Principal */
        #main-menu {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 10; color: white;
        }
        h1 { font-size: 3rem; text-transform: uppercase; letter-spacing: 5px; margin-bottom: 40px; text-shadow: 0 0 10px #4facfe; }
        
        .btn {
            padding: 15px 40px; margin: 10px; font-size: 1.5rem;
            background: transparent; color: white; border: 2px solid #4facfe;
            cursor: pointer; transition: 0.3s; border-radius: 30px; text-transform: uppercase;
            width: 300px;
        }
        .btn:hover { background: #4facfe; color: #000; box-shadow: 0 0 20px #4facfe; }

        /* Botões Flutuantes (Voltar e Pausar) */
        #controls-container {
            position: absolute; top: 20px; left: 20px; z-index: 5;
            display: none;
        }
        #back-btn, #pause-btn {
            padding: 10px 20px; margin-right: 10px;
            background: rgba(255, 0, 0, 0.7);
            color: white; border: none; cursor: pointer; 
            font-size: 1rem; border-radius: 5px;
        }
        #pause-btn {
            background: rgba(0, 150, 255, 0.7);
        }
    </style>
</head>
<body>

    <audio id="ambient-music" loop muted preload="auto"></audio>
    
    <div id="main-menu">
        <h1>Cosmos Explorer</h1>
        <button class="btn" onclick="iniciarJogo('solar')">Jogar (Sistema Solar)</button>
        <button class="btn" onclick="iniciarJogo('mapa')">Mapa Mundi</button>
    </div>

    <div id="controls-container">
        <button id="back-btn" onclick="voltarMenu()">Voltar ao Menu</button>
        <button id="pause-btn" onclick="togglePause()">Pausar Rotação</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        let animationId;
        let planets = []; 
        let audio; 
        let isPaused = false; 
        
        // --- CONFIGURAÇÃO DE CAMINHOS E ESCALAS ---
        const REPO_NAME = 'Solar-System'; 
        
        // ESCALA CORRIGIDA (valores que sugeri)
        const STAR_SPHERE_RADIUS = 5000; 
        const MAX_CAMERA_DISTANCE = 4500; 
        
        // TAMANHOS DOS PLANETAS (raio em unidades)
        const PLANET_SIZES = {
            sun: 25,
            mercury: 0.4,
            venus: 0.95,
            earth: 1.0,
            moon: 0.27,
            mars: 0.5,
            jupiter: 8,
            saturn: 7,
            uranus: 4,
            neptune: 4
        };
        
        // DISTÂNCIAS DO SOL (unidades)
        const PLANET_DISTANCES = {
            mercury: 60,
            venus: 100,
            earth: 150,
            mars: 230,
            jupiter: 450,
            saturn: 800,
            uranus: 1300,
            neptune: 1900
        };
        
        // VELOCIDADES DE ROTAÇÃO (órbita)
        const ORBIT_SPEEDS = {
            mercury: 0.04,
            venus: 0.015,
            earth: 0.01,
            mars: 0.008,
            jupiter: 0.002,
            saturn: 0.0009,
            uranus: 0.0004,
            neptune: 0.0001
        };
        
        // Fator de escala para visualização (multiplica os tamanhos reais)
        const SIZE_SCALE_FACTOR = 20;

        function buildPath(folder) {
            const isGitHubPages = window.location.host.includes('github.io');
            if (isGitHubPages) {
                return `/${REPO_NAME}/${folder}/`;
            } else {
                return `./${folder}/`;
            }
        }

        const texturePath = buildPath('textures'); 
        const AUDIO_FILE_PATH = buildPath('audio') + 'space_ambient.mp3'; 
        
        const textureLoader = new THREE.TextureLoader();

        const textureFiles = {
            stars: 'stars.jpg', sun: 'sun.jpg', mercury: 'mercury.jpg', venus: 'venus.jpg',
            earth: 'earth.jpg', moon: 'moon.jpg', mars: 'mars.jpg', jupiter: 'jupiter.jpg',
            saturn: 'saturn.jpg', uranus: 'uranus.jpg', neptune: 'neptune.jpg',
            worldMap: 'world_map_political.jpg' 
        };

        function loadTexture(name) {
            const path = texturePath + textureFiles[name];
            return textureLoader.load(
                path, 
                undefined, 
                undefined, 
                (err) => console.warn(`Textura ${name} não encontrada em ${path}. Usando cor padrão.`)
            );
        }

        function init() {
            const container = document.body;
            scene = new THREE.Scene();

            // Far clip da câmera ajustado para cobrir o raio de 5000
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 6000); 
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);
            
            // Habilita o mapeamento de sombras no Renderizador
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; 

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.minDistance = 1; 
            
            // Função de callback para limitar câmera
            controls.addEventListener('change', limitCameraPosition);
            
            audio = document.getElementById('ambient-music');
            audio.src = AUDIO_FILE_PATH;

            window.addEventListener('resize', onWindowResize);
        }

        // --- FUNÇÃO PARA LIMITAR CÂMERA (IMPORTANTE!) ---
        function limitCameraPosition() {
            const distance = camera.position.length();
            
            if (distance > MAX_CAMERA_DISTANCE) {
                // Puxa a câmera de volta para o limite
                const direction = camera.position.clone().normalize();
                camera.position.copy(direction.multiplyScalar(MAX_CAMERA_DISTANCE));
                controls.update();
            }
        }

        // --- FUNÇÕES DE CONTROLE (Pausa e Áudio) ---
        window.togglePause = function() {
            isPaused = !isPaused;
            const button = document.getElementById('pause-btn');
            button.textContent = isPaused ? 'Continuar Rotação' : 'Pausar Rotação';
        }

        function toggleAudio(play) {
            if (!audio) return;
            if (play) {
                audio.muted = false; 
                audio.volume = 0.4;
                audio.play().catch(e => console.error("Não foi possível tocar o áudio. Verifique o caminho e tamanho do arquivo.", e));
            } else {
                audio.pause();
            }
        }

        // --- MODO 1: SISTEMA SOLAR ---
        function createSolarSystem() {
            // Posição inicial da câmera ligeiramente mais afastada para ver o sistema
            camera.position.set(0, 200, 700); 
            
            // Background (RAIO: 5000)
            const starGeo = new THREE.SphereGeometry(STAR_SPHERE_RADIUS, 64, 64);
            const starMat = new THREE.MeshBasicMaterial({ 
                map: loadTexture('stars'), 
                side: THREE.BackSide 
            });
            const starSphere = new THREE.Mesh(starGeo, starMat);
            scene.add(starSphere);

            // Sol (RAIO: 25)
            const sunGeo = new THREE.SphereGeometry(PLANET_SIZES.sun, 64, 64);
            const sunMat = new THREE.MeshBasicMaterial({ 
                map: loadTexture('sun'),
                emissive: 0xffaa33,
                emissiveIntensity: 0.5
            });
            const sun = new THREE.Mesh(sunGeo, sunMat);
            scene.add(sun);
            
            // LUZ BRANCA DO SOL (PointLight)
            const sunLight = new THREE.PointLight(0xffffff, 2, 10000); 
            sunLight.position.set(0, 0, 0); 
            
            // Luz do Sol EMITE SOMBRAS
            sunLight.castShadow = true; 
            sunLight.shadow.mapSize.width = 2048; 
            sunLight.shadow.mapSize.height = 2048; 
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 3000;
            scene.add(sunLight);
            
            // Luz Ambiente (muito fraca)
            const ambientLight = new THREE.AmbientLight(0x020202); 
            scene.add(ambientLight);

            // Dados dos planetas na ordem correta
            const planetOrder = ['mercury', 'venus', 'earth', 'mars', 'jupiter', 'saturn', 'uranus', 'neptune'];
            
            planetOrder.forEach(planetName => {
                const size = PLANET_SIZES[planetName] * SIZE_SCALE_FACTOR;
                const distance = PLANET_DISTANCES[planetName];
                const speed = ORBIT_SPEEDS[planetName];
                
                const geo = new THREE.SphereGeometry(size, 64, 64);
                const mat = new THREE.MeshStandardMaterial({ 
                    map: loadTexture(planetName),
                    roughness: 0.9 
                });
                const mesh = new THREE.Mesh(geo, mat);
                
                // Planetas Recebem e Projetam Sombras
                mesh.receiveShadow = true;
                mesh.castShadow = true; 
                
                const pivot = new THREE.Object3D();
                pivot.add(mesh);
                scene.add(pivot);
                mesh.position.x = distance;

                // Lua da Terra (apenas para Terra)
                if (planetName === 'earth') {
                    const moonSize = PLANET_SIZES.moon * SIZE_SCALE_FACTOR;
                    const moonGeo = new THREE.SphereGeometry(moonSize, 32, 32); 
                    const moonMat = new THREE.MeshStandardMaterial({ 
                        map: loadTexture('moon'),
                        roughness: 0.9
                    });
                    const moonMesh = new THREE.Mesh(moonGeo, moonMat);
                    
                    moonMesh.receiveShadow = true;
                    moonMesh.castShadow = true; 

                    const moonPivot = new THREE.Object3D();
                    
                    // Posiciona o pivot da lua na Terra
                    moonPivot.position.x = distance;
                    // Distância da Lua à Terra
                    moonMesh.position.x = size * 2.5; 
                    
                    pivot.add(moonPivot); 
                    moonPivot.add(moonMesh);
                    
                    // Adiciona rotação orbital da lua
                    planets.push({ 
                        mesh: moonMesh, 
                        pivot: moonPivot, 
                        speed: speed * 10,
                        orbitRadius: size * 2.5,
                        orbitCenter: mesh.position
                    });
                }
                
                // Adiciona rotação do planeta e órbita
                planets.push({ 
                    mesh: mesh, 
                    pivot: pivot, 
                    speed: speed,
                    rotationSpeed: 0.005
                });
            });
            
            // Anéis de Saturno
            createSaturnRings();
        }
        
        function createSaturnRings() {
            const saturnDistance = PLANET_DISTANCES.saturn;
            const saturnSize = PLANET_SIZES.saturn * SIZE_SCALE_FACTOR;
            
            // Encontrar Saturno na lista de planetas
            const saturnIndex = planets.findIndex(p => p.mesh.position.x === saturnDistance);
            if (saturnIndex !== -1) {
                const saturn = planets[saturnIndex];
                const ringGeometry = new THREE.RingGeometry(saturnSize * 1.2, saturnSize * 2.5, 64);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: 0xDAA520,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.6
                });
                const ringMesh = new THREE.Mesh(ringGeometry, ringMaterial);
                ringMesh.rotation.x = Math.PI / 2;
                saturn.pivot.add(ringMesh);
            }
        }

        // --- MODO 2: MAPA MUNDI ---
        function createWorldMap() {
            camera.position.set(0, 0, 25);
            
            const dirLight = new THREE.DirectionalLight(0xffffff, 5); 
            dirLight.position.set(5, 3, 5);
            scene.add(dirLight);

            const ambientLight = new THREE.AmbientLight(0x888888); 
            scene.add(ambientLight);

            // Globo Terrestre (Raio 10)
            const geo = new THREE.SphereGeometry(10, 64, 64);
            const mat = new THREE.MeshStandardMaterial({ 
                map: loadTexture('worldMap'),
                roughness: 0.7, 
                metalness: 0.1 
            });
            const earth = new THREE.Mesh(geo, mat);
            earth.receiveShadow = true;
            earth.castShadow = true; 
            scene.add(earth);

            // Rotação automática desativada (speed = 0)
            planets.push({ mesh: earth, pivot: null, speed: 0.0, rotationSpeed: 0.002 }); 
        }

        // Loop de Animação
        function animate() {
            animationId = requestAnimationFrame(animate);
            controls.update();

            if (!isPaused) {
                planets.forEach(p => {
                    // Rotação do planeta
                    if (p.rotationSpeed) {
                        p.mesh.rotation.y += p.rotationSpeed;
                    }
                    
                    // Órbita ao redor do Sol (se tiver pivot)
                    if (p.pivot) {
                        p.pivot.rotation.y += p.speed;
                    }
                });
            }

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- LÓGICA DO MENU ---
        window.iniciarJogo = function(modo) {
            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('controls-container').style.display = 'flex';
            isPaused = false;
            document.getElementById('pause-btn').textContent = 'Pausar Rotação';

            if (!renderer) init();

            // Limpar cena
            while(scene.children.length > 0){ 
                scene.remove(scene.children[0]); 
            }
            planets = []; 

            if (modo === 'solar') {
                createSolarSystem();
                // Configura limites do OrbitControls
                controls.maxDistance = MAX_CAMERA_DISTANCE;
                controls.minDistance = 5;
            } else {
                createWorldMap();
                // Limite de afastamento para o Mapa Mundi
                controls.maxDistance = 30;
                controls.minDistance = 5;
            }
            
            // Atualizar controls após mudar limites
            controls.update();
            
            toggleAudio(true); 
            animate();
        };

        window.voltarMenu = function() {
            cancelAnimationFrame(animationId);
            document.getElementById('main-menu').style.display = 'flex';
            document.getElementById('controls-container').style.display = 'none';
            
            toggleAudio(false); 
            
            // Resetar controles
            if (controls) {
                controls.reset();
            }
        }
        
        // Inicializar quando a página carregar
        window.addEventListener('DOMContentLoaded', () => {
            // Pré-carregar texturas para evitar delays
            Object.keys(textureFiles).forEach(key => {
                textureLoader.load(texturePath + textureFiles[key]);
            });
        });
    </script>
</body>
    </html>
